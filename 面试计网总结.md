

# 面试计网总结

------

## 目录

[TOC]

------

## 七层模型

| OSI  七层模型 | TCP/IP协议簇五层模型 |
| :-----------: | :------------------: |
|    应用层     |                      |
|    会话层     |                      |
|    表示层     |        应用层        |
|    传输层     |        传输层        |
|    网络层     |        网络层        |
|  数据链路层   |      数据链路层      |
|    物理层     |        物理层        |

------

## 应用层协议

HTTP、SNMP、Telnet、DNS、FTP、SMTP

##### HTTP

传输编码：

- chunked

内容编码：常用的

- gzip	采用GNU zip编码
- compress    采用Unix的文件压缩
- deflate    采用zlib
- br    采用Brotli
- identity    没有编码，默认值

E-Tag标签：标识一个文件在两次请求间是否发生变化的标志，如果未发生变化，服务端返回304表示数据没有变化，客户端可以从缓存读取

##### SNMP(Simple Network management Protocol)

简单网络管理协议：使管理员通过一台工作站完成对计算机、Route、其他远程设备的远程管理和监视。利用SNMP可以更好的管理和监控网络。

**不使用面向连接传输服务！使用UDP**

##### 邮件相关协议：

- POP3
- SMTP
- IAMP

------

## 传输层相关

|          |   UDP    |    TCP     |
| :------: | :------: | :--------: |
|   连接   |  无连接  |  面向连接  |
|   可靠   |  不可靠  |    可靠    |
| 传输内容 | 面向报文 | 面向数据流 |
|  连接数  |   1:1    |    m:n     |
|   首部   |    8     |     20     |
| 逻辑信道 |  不可靠  | 全双工可靠 |
| 传输效率 |    快    |     慢     |

|        |    TCP     |         UDP          |
| :----: | :--------: | :------------------: |
|  FTP   |  文件传输  |                      |
|  SMTP  |  邮件服务  |                      |
|  POP   |  接收邮件  |                      |
| Telnet |  远程登录  |                      |
|  HTTP  | 超文本传输 |                      |
|  DNS   |            |       域名解析       |
|  SNMP  |            |     管理网络设备     |
|  TFTP  |            |      simpleFTP       |
|  DHCP  |            | 动态主机配置(IP分发) |

### TCP如何保证可靠？

- 数据分块
- SYN 和ACK
- 校验和
- 流量控制-->滑动窗口
- 拥塞控制
- ARQ
- 超时重传

### UDP为何不可靠？

- 只有一个socket接受缓冲，没有发送，有数据就发送，不管是否接受，接受缓冲满了就丢包
- 没有流量控制和重传
- connect：记录对端到IP和PORT，可以多次调用，效率高，高并发稳定
- bind：将一个套接字指定一个端口，提高性能

### TCP超时重传:

定时器，发送一次开启一个，没得到ACK就重新发送，一定次数后就放弃重传发送一个RST信号

------

## 拥塞控制

[返回顶部](#目录)

窗口滑动协议、快速重传、拥塞避免、慢启动

### 窗口滑动协议：

通过一个由接收方确定大小的一个窗口大小，对双方能够同时发送的帧的数量进行限制，可以在未收到ACK的情况下，发送小于等于窗口大小的帧，在未发生拥塞的情况下能够有效减小吞吐量！

可能会发生接受窗口满了，会发送一个报文说明窗口大小为0，如果也丢包，就会死锁---->需要一个计时器来查询

遇到超时则需要重发

因此需要停等协议：发送方 发送后等待确认，收到ACK就继续，超时或NAK就重传

GBK后退N帧协议：从错误的位置重新发送W(窗口大小)个数据帧

↓(优化)

SR选择重传协议：出现错误时将后续的缓存，仅重传错误的数据帧，但是会要求接收方有更大的缓存

### TCP拥塞控制

拥塞：对资源的需求超过了可用的资源，如果出现许多供应不足就会影响整个网络的吞吐量

拥塞控制：防止过多的数据注入到网络中，s.t网络的路由和链路不过载。是个全局过程

- 前提：网络能承受现有的网络负荷
- 代价：需要获得网络的流量分布，有额外开销，资源不能很好共享

#### 控制方法：慢开始、拥塞避免、快速重传、快恢复

##### 慢开始和拥塞避免：AIMD(加法增大乘法减小)

拥塞窗口变量：cwnd ->网络拥塞程度

慢开始：不知道现在网络负荷，由小到大增加发送窗口，最开始设置为1个MSS(max segment size)收到一个确认ACK就把cwnd增加一个MSS，(每次都发送cwnd大小的数据包)每传输一次cwnd翻翻

拥塞控制：防止慢启动时cwnd增加过快导致拥塞，需要设置一个**ssthresh  慢开始门限**标志控制

拥塞控制时，经过一个RTT，cwnd+1

| cwnd < ssthresh |  慢启动  |
| :-------------: | :------: |
| cwnd = ssthresh |   均可   |
| cwnd > ssthresh | 拥塞控制 |

无论哪种，出现拥塞就**ssthresh = cwnd / 2      cwnd = 1 继续慢启动**

------

##### 快速重传、快速恢复

快速重传：在出现丢包时，接收方未收到当前包，收到失序报文段时，对上一个收到的包再次进行确认，当出现3次重复确认(共四次对同一个包的确认)，就立刻对确认包的下一个包进行发送。可以提高吞吐量20%

快速恢复：三次重复确认就执行乘法减小->**ssthresh = 1/2 * ssthresh，然后执行拥塞控制**

### 拥塞控制状态机Congestion Control State Machine

![截屏2021-08-18 下午9.22.42](/Users/serein_x/Library/Application Support/typora-user-images/截屏2021-08-18 下午9.22.42.png)

1. open
2. Disorder
3. CWR    Congestion Window Reduced
4. Recovery
5. Loss

------

## TCP三次握手、四次挥手

[返回顶部](#目录)

### 三次握手

第一次：client 发送SYN包 包括一个随机的seqnum =  client_isn 发送到服务器请求连接 客户端进入 SYN_SEND 状态

第二次：server 收到SYN包，返回确认ACK包和SYN包，ACK包中状态码ackNum = isn + 1，SYN = 1，seqNum = server_isn 随机，服务器进入SYN_RECEIVE状态

第三次：客户端 收到SYN+ACK包，返回确认包ACK，ack Num= server_isn + 1 进入ESTABLISHED状态，server收到ACK包也进入相同状态。

###  四次挥手

客户端(服务端任意一方)：发送SYN+FIN报文段，syn Num = client_isn 进入FINISH_WAIT_1

服务端：收到FIN报文，返回确认包ACK，ack num = client_isn + 1，客户端收到后进入FINISH_WAIT_2状态，发出后客户端进入CLOSE_WAIT状态

服务端传送完后，发送SYN+FIN报文段，syn num = server_isn 进入LAST_ACK阶段，等待确认

客户端收到后，返回ACK，ack = server_isn + 1进入TIME_WAIT阶段，服务器收到ACK包，就关闭，客户端等待2MSL后无消息就关闭

------

初始化序列号 ISN 这个值是随机的

- 意义在于让对方生成一个合法的接收窗口
- 动态随机
  - 为了增加安全性，避免第三方猜测，从未被第三方伪造的RST报文Reset 
  - 造成TCP会话劫持攻击
- ISN动态随机使得每个tcp session的字节序列号没有重叠，如果出现tcp五元组冲突这种极小概率情况的发生，一个session的数据也不会被误认为是另一个session的。
- isn 计算方式：

$$
ISN = M + F(localhost + localport + remotehost + remoteport)
$$

//M是个计时器	F是个哈希算法选择MD5

- 伪造RST报文：ISN动态随机，猜测难度大，假设ISN = 0 容易猜出

------

三次握手第一次不可携带数据：未完成连接建立

三次握手第三次可以携带数据：能够发出第三次SYN+ACK报文，一定可以接收第二次的报文，因此是合法用户，在第三次握手的瞬间，状态变为ESTABLISHED，即可接收数据

如果第一次将数据缓存，会放大SYN FLOOD攻击

**看到有人说，只看到过TCP状态位为** **’FIN +ACK’，但从来没有看过状态位只有** **‘FIN’，你应该怎样给他解释？**RFC793明确规定，除了第一个握手报文SYN除外，其它所有报文必须将ACK = 1。

TCP作为一个可靠传输协议，其可靠性就是依赖于收到对方的数据，ACK对方，这样对方就可以释放缓存的数据，因为对方确信数据已经被接收到了。

**但TCP报文是在IP网络上传输，丢包是家常便饭，接收方要抓住一切的机会，把消息告诉发送方。最方便的方式就是，任何我方发送的TCP报文，都要捎带着ACK状态位。**

------

why 三次 不是 两次 四次？

- 三次握手可以阻止重复历史链接初始化！

RFC 792说：首要原因是为了防止旧的重复链接初始化造成混乱，因为会有丢包存在。

client 发送两个包，旧SYN先到，server 发送SYN+ACK 这时client 发现ack num 不正确，发送 RST 中止链接

两次握手做不到

- 三次握手才可以同步双方初始ISN
  - 接收方去除重复数据
  - 根据isn按序接收
  - 标识发送的包，哪些被收到
- 三次握手才可以避免资源浪费

如果两次握手，当SYN被阻塞时，client重发SYN，但server未知client是否收到ACK，因此每个SYN都会建立一个ACK，会有多个冗余链接，资源浪费。

------

why 四次挥手？

​	发送FIN表示不发送数据，但可接收数据，因此双方均需要一个不在发送数据的FIN报文

why TIME_WAIT是2MSL？

​	在 Linux 系统里 `2MSL` 默认是 `60` 秒，那么一个 `MSL` 也就是 `30` 秒。**Linux 系统停留在 TIME_WAIT 的时间为固定的 60 秒**。

why TIME_WAIT？

防止相同的[四元组]的旧数据包被收到	-->   time < 2MSL

![https://pic4.zhimg.com/80/v2-5e3336e73d8b924381f347d0ebab1b71_720w.jpg?source=1940ef5c](https://pic4.zhimg.com/80/v2-5e3336e73d8b924381f347d0ebab1b71_720w.jpg?source=1940ef5c)

保证被动关闭的以放能正确关闭，最后的ACK被接收到，不会被阻塞

TCP 就设计出了这么一个机制，经过 `2MSL` 这个时间，**足以让两个方向上的数据包都被丢弃，使得原来连接的数据包在网络中都自然消失，再出现的数据包一定都是新建立连接所产生的**

TIME_WAIT过长？

内存占用

端口占用，如果过多占满所有端口则无法建立新连接

可以使用SO_REUSEADDR套接字来通知内核，端口被占用时，TCP如果处于TIME_WAIT可以重用端口

为什么基于TCP的程序往往都有个应用层的心跳检测机制？
是为了预防建立好的连接突然客户端故障了，服务器不能一直等待下去，需要一个计时器和探测包来检测

------

## 输入域名访问网站后发生了什么？

[返回顶部](#目录)

1. 浏览器查找对应IP

   查询顺序:先查浏览器缓存->再查路由缓存->DNS缓存->上层DNS

  2.通过TCP协议建立TCP连接

​		建立连接前找到对应路径，通过OSPF开放式最短路径优先决定经过哪些路由，ARP计算中间节点地址，IP转换MAC…………CDN…………网站前后端分离，访问时先访问反向..负载均衡...

  3.通过HTTP请求网页内容

​		包括cookie

  4.服务器对HTTP请求处理

​		J2EE

  5.服务器回应HTML：根据响应开始显示页面，首先解析HTML构建DOM树，然后解析CSS文件构建渲染树、布局渲染树将其绘制到屏幕上。

  6.对HTMl进行解析并显示

  7.断开连接，四次挥手

### 负载均衡：

Load Balance，将负载进行平衡、分摊到多个单元进行，一种透明、廉价有效的方法，扩展网络和服务器带宽，增加吞吐量、增加处理能力。

### J2EE：

**当WEB客户把HTTP请求发给Servlet容器会发生什么？**

1. WEB客户向Servlet容器发送HTTP请求
2. Servlet容器接收到HTTP请求
3. Servlet容器创建一个HttpRequest对象，在对象中封装HTTP信息
4. Servlet容器创建一个HttpResponse对象
5. Servlet容器把HttpRequest和HttpResponse作为参数，调用HttpServlet的service方法![容器收集信息，创建请求与相应对象](https://img-blog.csdn.net/20171213134742742?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQUxlbW9uX1k=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)
6. service方法中，根据request的mothod是GET还是POST决定调用doGet还是doPost
7. HttpServlet调用HttpRequest有关方法，获得HTTP信息
8. HttpServlet调用HttpResponse有关方法，获得响应信息
9. Servlet容器将响应结果返回给WEB客户

------

## Memcache

#### 核心优化概述

什么是优化：以更小的资源支持更大负载网站的运行，以小博大。

思路：尽量减少用户等待时间，节省系统资源开销，节省带宽使用。

优化什么地方？有三方面：**Memcache内存缓存技术、静态化技术、mysql优化**

![img](http://p1.pstatp.com/large/567c00056acd27aa2290)

**内存缓存技术Memcache**：memcache是实现php语言 对内存 进行操作的中间介质。

![十分钟学会memcache，比你想象的要简单](http://p3.pstatp.com/large/567b0005e34c3c37b67d)

#### memcache与redis的区别和联系

- redis:支持比较多的数据类型(String/list/set/sortset/hash)，redis支持集合计算的(set类型支持)，每个key最大数据存储量为1G，redis是新兴的内存缓存技术，对各方面支持不完善，支持持久化操作。

- memcache：老牌的内存缓存技术，对相关领域支持比较丰富，window和linux都可以使用，各种框架(tp/yii等等)都支持使用，session的信息可以非常方便的保存到该memcache中，每个key保存的数据量最大为1M，支持的数据类型比较单一，就是String类型，不支持持久化。

**两者的相同之处在于把数据保存在内存中。**

#### 分布式部署memcache和Redis

Redis:是主从模式，一个Redis负责数据写入，其他多个redis负责数据读取

memcache不是主从模式，该分布式是平均分摊工作，每个子服务器平级的，每个服务器都要执行数据写入、读取。

#### 缓存失效

超过有效期：具体是通过“懒惰”机制删除该过期数据，与过期session的删除类似。

过期session删除机制：session是以文件形式保存的硬盘中，如果有的session文件已经过期了，则该session文件不会立即被删除，而是后期其他用户访问网站使用session的同时会有一定的几率触发删除过期的session文件。

memcache的过期数据删除也是懒惰机制实现，如果有一个key过期了，其本身不会马上被删除，而是我们调用get方法获取数据的同时会删除该过期的数据。

如果存储的数据超过memcache最大的存储限制(默认是64M)，此时还继续存入数据，则会把最近不常使用的key就删除了。该机制名称为LRU(least recently use)优先删除最近很好使用的key。

#### session存入memcache

session可以存入mysql数据库中。

需求：共享session信息

**session的信息以文件形式存储在服务器内部，不能实现多个服务器共享，只有存入的mysql或memcache中才可以实现数据共享。**

![十分钟学会memcache，比你想象的要简单](http://p1.pstatp.com/large/567e00042887a9fd8111)

mysql或memcache可以实现多个服务器彼此之间共享session信息。

------

## 什么是HTTPS协议，哪种密钥？

[返回顶部](#目录)

HTTPS = HTTP + SSL/TLS

HTTP明文发送 安全性不高 易被窃听、篡改、劫持

SSL/TLS有信息加密、身份验证、完整性验证等特点

### SSL协议：

分为两层：SSL记录协议||SSL握手协议

SSL Record Protocol 建立在TCP(或其他**可靠**传输协议上)提供数据封装、压缩加密等

SSL Handshake Protocol建立在SSL记录协议上，在实际数据传输前，身份认证、协商加密算法、交换密钥

SSL握手：五步、三个随机数、握手之后的对话使用"对话密钥"加密（对称加密），服务器的公钥和私钥只用于加密和解密"对话密钥"（非对称加密），无其他作用

但SSL握手的握手阶段是明文，第一、第二个随机数可被窃听，可以把默认的RSA改为DH，无需传递第三个参数![http://www.ruanyifeng.com/blogimg/asset/2014/bg2014092007.png](http://www.ruanyifeng.com/blogimg/asset/2014/bg2014092007.png)

#### 共享密钥加密（对称密钥加密）

加密和解密用同一个密钥

#### 公开密钥加密（非对称密钥加密）

每个人拥有一对公钥+私钥
 别人使用你的公钥加密文件后发给你，你用私钥解密阅读

#### 混合密钥加密

交换密钥的时候使用公开密钥加密。传送报文的时候采用共享密钥加密

#### session的恢复

session ID(只在一台服务器) 和 session ticket

session ticket：发送一个服务器在上一次对话中发送过来的session ticket。这个session  ticket是加密的，只有服务器才能解密，其中包括本次对话的主要信息，比如对话密钥和加密方法。当服务器收到session  ticket以后，解密后就不必重新生成对话密钥了。

#### SSL-pinning

![img](https://upload-images.jianshu.io/upload_images/1910166-f5b3c8dee0adb341.png?imageMogr2/auto-orient/strip|imageView2/2/w/605)

在某些情况下，对使用HTTPS协议进行通信的网页进行抓包时，会发生请求失败的情况，就是网页通过使用SSL-pinning的技术防止中间人攻击。

HTTPS通信过程中在建立信任过程中使用TLS，其中的交互产生了3个随机数，只有第3个是采用非对称加密的，因此MITM攻击关键是要截获这个证书，并伪造证书发送骗取信任，获得第3个随机数

![img](https://upload-images.jianshu.io/upload_images/1910166-a00119d6d580c2d3.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/1000)

SSL-pinning就是防止Charles/Fiddler等抓包攻击的。

在开发时将服务端证书打包在客户端里，在建立HTTPS链接时，与服务端返回的证书对比一致性，进而识别出中间人攻击，在客户端侧中止链接

绕过：HOOK

------

## 什么是SOCKET？

[返回顶部](#目录)

对TCP/IP协议的封装，应用层和TCP/IP协议族通信的中间抽象层，调用接口API

socket & http

socket：不是协议，有TCP/UDP||socket是长连接，不会主动断开，没有数据传输，维持连接需要发送心跳消息。||socket传输的数据可自定义，字节级，数据量小，可加密，安全，实合实时

适合：推送，聊天

http：是协议，短链接，server 响应后就断开||无状态协议，一般通过session/cookie||传输速度慢，包大，安全差，实时交互server压力大

适合：图片上传、新闻获取等。

------

## 什么是IO、什么是NIO、AIO、netty框架？

[返回顶部](#目录)

IO：输入输出设备及输入输出接口

BIO -> block IO 同步阻塞IO：socket就是BIO，每个socket要用一个线程处理，建立连接、读写时都可能阻塞。连接无操作时有线程开销->用线程池解决。

![深入分析JAVA IO（BIO、NIO、AIO）](http://p3.pstatp.com/large/pgc-image/124abc4e9360444996c09a1144d0418c)

NIO->同步非阻塞IO：多个连接一个线程，多个连接到服务器的socket中，只有需要进行IO操作的	才能获取到服务端的处理线程，进行IO。

客户端的socket连接到服务端时，就会在事件分离器注册一个 IO请求事件 和 IO 事件处理器。在该连接发生IO请求时，IO事件处理器就会启动一个线程来处理这个IO请求，不断尝试获取系统的IO的使用权限，则通知这个socket进行IO数据传输。![深入分析JAVA IO（BIO、NIO、AIO）](http://p1.pstatp.com/large/pgc-image/c37fb54a0eae4d06aca940c8fd1cc89a)

AIO->异步阻塞IO：AIO是发出IO请求后，由操作系统自己去获取IO权限并进行IO操作；NIO则是发出IO请求后，由线程不断尝试获取IO权限，获取到后通知应用程序自己进行IO操作。![深入分析JAVA IO（BIO、NIO、AIO）](http://p3.pstatp.com/large/pgc-image/dae158c81f664650a19457a90da99c99)

### netty框架

netty是用来实现非阻塞IO的一个框架 

------

## HTTP是无状态的，如何保存用户状态？

HTTP协议并不会保存关于客户机的任何信息，是一个无状态协议

### 基于session实现的会话保持

客户端第一次发送一个HTTP请求后，server创建一个session对象，将客户端身份信息以键值对的形式储存，分配一个会话标识SessionID给客户端，一般保存在cookie中，后面每次请求都带上cookie中的sessionID到服务器，就可以实现会话保持。

优点：safe！

缺点：大型网站使用CDN，如果两次HTTP请求被分配在不同server就不能保持会话。

解决方案：Redis中间件

### 基于Cookie实现会话保持

server发送相应消息时，在HTTP响应头中设置Set-Cookie字段，来储存客户端的状态信息，每次发送HTTP请求都带上cookie实现保持。

两者不同是，Cookie完全将会话状态信息储存在浏览器cookie中

优点：服务器压力小，便于服务端做水平拓展

缺点：不安全，占用带宽

#### cookie被BAN怎么办？

重写URL，将标识放在URL参数中也可

[返回顶部](#目录)

------

## 状态码

| 分类 | 描述       |
| ---- | ---------- |
| 1xx  | 正在处理   |
| 2xx  | 成功       |
| 3xx  | 重定向     |
| 4xx  | 客户端错误 |
| 5xx  | 服务器错误 |

100继续处理	200 ok	301 永久移动	302 临时移动	400 Bad Request语法错误	403 ForBidden 拒绝执行	404 Not Found 请求失败	502 无响应

[返回顶部](#目录)

------

## HTTP/1.1 和 HTTP/1.0 区别，以及HTTP/1.x 和 HTTP/2.0

|            | 1.0                                         | 1.1                                                          |
| ---------- | ------------------------------------------- | ------------------------------------------------------------ |
| 缓存       | header中if-modified-Since判断               | 有更多字段Entity-tag \|\| if-Unmodified-Since \|\| if-Match  |
| 节约带宽   | 默认将资源相关WHOLE对象传送过去             | 引入Range，可以请求部分                                      |
| 错误通知   | basic                                       | 新增24个状态码                                               |
| Host请求头 | 早期一个server一个IP，单一服务              | 虚拟主机，一个server多个IP多种服务，so1.1增加了host请求头    |
| 长链接     | 默认短暂联接，每次都要一个TCP，完成后就断开 | 默认持久链接，一个TCP中多个HTTP请求，旧版本中要持久连接用Keep-Alive |

HTTP/2.0使用二进制传送，数据拆分为帧，采用数据流

**2.0支持多路复用，通过流ID，一个HTTP请求多个资源**

**2.0压缩头部gzip和compress维护一个头信息表，只需传索引**

**2.0支持服务器推送**

#### HTTP/3	QUIC协议

[返回顶部](#目录)

------

## DNS原理作用

本质是一个分布式数据库，存储了域名和IP地址的互相映射

本地DNS

#### DNS使用UDP？

DNS使用TCP和UDP：域名查询的时候使用UDP，进行区域传送的时候使用TCP，因为报文长度的限制。

------

## DNS劫持？

将原域名替换而无法正常访问的攻击方式，需要在特定的网络范围中进行

------

## socket()套接字有哪些？

对网络中进程间的双向通信端点进行抽象，Eg:TCP使用IP+PORT作为连接端点，即为套接字

- 流套接字SOCK_STREAM，基于TCP，提供面向连接，可靠的传输
- 数据报套接字SOCK_DGRAM基于UDP，对应无连接的UDP服务应用不可靠，不长链接
- 原始套接字SOCK_RAW传输非传输层的数据报(Eg:ICMP)就用这个发送

[返回顶部](#目录)

------

## SYN FLOOD

#### 应对：

- 提高TCP端口容量，减少半开资源占用时间
- 部署辨别恶意IP的路由器，过滤SYN消息

作用不大 ⬆️

- SYN Cache：构造全局HashTable(?)，缓存连接信息，Table满了就丢弃最早的信息
  - 也许可以用LRU的思路，使用LinkedHashMap代替HashTable，使用accessorder参数置为true时，LinkedHashMap是有序的
- SYN Cookies：类似HTTP Cookies通过算法将信息编码序列发送给客户端，发送方确认ACK到达的时候验证编码无误再分配资源建立连接

⬆️不能超时重传

- SYN Proxy：部署代理，类似防火墙，client和firewall建立成功后把消息发给server

[返回顶部](#目录)

------

## IP协议 & 网络层

不可靠/无连接

- 寻址和路由：IP包携带源IP、目的IP标识主机，IP数据报传输时中间节点只根据网络地址转发，IP Protocol通过路由选择协议来转发
- 分段、重组：某些网络中对包最大长有限制，需要IP协议来分配一个标识符和分段重组的相关信息，使得其能够传输，到达目的后重组

### **IP唯一、域名不唯一**

一个域名也可以对应多个IP，可以使用多个DNS服务器，但是不够灵活

### IPV4不够咋办？

- DHCP：动态主机协议，充分利用空闲IP
- CIDR：无类别域间路由
- NAT：网络地址转换，不同局域网内的主机可以使用相同IP
- IPv6

[返回顶部](#目录)

------

### 路由的分组转发

1. IP包中获得地址
2. 判断所在网络是否直连
3. 检查路由表中是否有特定主机路由
4. 3没有就执行4，逐条检查找到匹配就发送到下一跳
5. 转发至默认路由
6. 报错

------

### 路由器 & 交换机

交换机：局域网，利用mac确定地址，硬件工作，速度快，工作简单--->数据链路层

路由器：通过IP，网络号唯一，软件实现，较慢，复杂路由 --->网络层

------

### ICMP：因特网控制报文协议

​	不传输data，传输控制信息辅助网络层通信。主要验证网络是否畅通

应用：

- ping
- TraceRoute：跟踪分组从源点耗费最少TTL到达目的路径，先发TTL = 1，后发TTL = 2直到刚好到达主机

[返回顶部](#目录)

------

### ARP地址解析协议---->数据链路层协议

地址解析协议，根据提供的IP获取对应的MAC地址，发送IP数据包时，需要封装IP和MAC，如果目前主机没有对应的MAC地址就需要首先使用ARP

------

### NAT

网络地址转换，将内网私有地址，类似192.168.1.2翻译成为公网IP地址的技术，解决IP不足，保护隐藏内网主机

- 静态转换：1:1，内网IP 对应 共有IP 不会改变	外部网络对内网特定设备访问
- 动态转换：私有IP每次转化结果不一样，私有IP被授权访问Internet时会随机转化一个合法的IP，ISP通过的合法IP < 网络内PC数量，可以使用
- 端口多路复用：将外部数据包的**源端口进行端口转换**，通过端口多路复用的方式，实现内网所有主机共享一个合法外部IP进行Internet访问，能够节约IP资源。隐藏内网主机

------

### 运输层协议提供进程间的逻辑通信，网络层协议提供主机间的逻辑通信

[返回顶部](#目录)

------

## 数据链路层

### MAC和IP作用

MAC是网卡上的物理地址，MAC地址定义网络设备的位置，唯一

IP是网络层及以上使用的，是逻辑地址，区别主机

#### 有MAC	why	IP？

只用MAC需要路由储存MAC属于哪个子网，需要空间太大

IP地域相关，一个子网的，IP前缀一样，减少路由需要的内存

#### 有IP	why	MAC？

没分配IP时需要MAC区分

------

#### 公有私有地址转换：一个局域网的俩私有网络地址转换后一样🐎？

静态、动态NAT时不一样，端口多路复用NAT时一样，但端口不同

------

### CSMA/CD

以太网广播，解决共享信道的问题

- 载波监听：使用CSMA/CD时，各节点均在监听是否有信号传输，有就Keep 监听，空闲就发送数据
- 冲突检测：两个节点都监听到空闲并传送数据就冲突，以太网停止传输，发送冲突信号，采用二进制退到方式使其继续等待并传输

------

封装成帧：网络层包需要➕首位成帧

透明传输：帧通过首尾定界，首尾相同需要转义，传输完要还原

差错校验：CRC

------

## 主机间通信方式---物理层

- 单工通信：发送和接收方确定不可变
- 半双工通信：双方都能发送，但不能同时
- 全双工通信：可同时双向发送

------

### 宽带接入技术：

ADSL	非对称用户环路 上行低下行高 家庭

FTTx + LAN	光纤线路 + 局域网 20Mbps 普及

[返回顶部](#目录)

------

## 网络安全

主动攻击：

被动攻击：

------

### ARP攻击

主机ARP表可更改，一直发送ARP报文，将源MAC换为攻击者MAC，源IP是被攻击的IP，不断发送，内网所有网关和主机都改为攻击者MAC ------>所有消息都会发给攻击者

- 洪泛攻击：网关、路由、交换机发送ARP，阻塞CPU，导致不相应正常请求
- 欺骗主机：消息发给攻击者，窃取数据
- 欺骗网关：局域网主机向网关发送信息都给攻击者，数据泄露
- 中间人：同时欺骗网关和主机
- IP地址冲突：扫描主机，根据MAC进行攻击，导致局域网内主机IP冲突，无法正常使用

[返回顶部](#目录)

------

### 非对称：RSA || ElGamal || Rabin || DH || 背包

------

### AES：明文分组->字节替代->行位移->列变化->轮密钥加

------

### DDoS

攻击者借助不同位置主机对受害者发起攻击

#### 流量攻击	和	资源耗尽攻击

- 流量攻击：针对带宽，发送大量攻击到主带宽被阻塞
- 资源耗尽攻击：针对服务器，大量数据包使得服务器资源耗尽或者CPU被内核应用程序占满，无法提供服务

#### 常见DDoS

- SYN Flood
- DrDos
- HTTP Flood

#### 应对

流量：增加带宽、流量清洗、提升配置

资源耗尽：升级服务器硬件、DDoS防火墙、负载均衡、CDN

