蚂蚁金服面经

一面

HashMap和HashTable区别

​	1.HashMap 和 Hashtable都是双列集合，底层都是哈希算法

​	2.不同点:

HashMap是线程不安全的，效率高

Hashtable是线程安全的，效率低



HashMap可以存储null键和null值

Hashtable不能存储null键和null值



~~~java
public class testHashtable{
	public static void main(String []args){
    HashMap<String,Integer> map = new HashMap<>();
    map.put(null,1);
    map.put("aaa",null);
    System.out.println(map);
    
    Hashtable<String,Integer> table = new Hashtable<>();
    table.put(null,1);
    table.put("aaa",null);
    System.out.println(table);
  }
}
~~~

接口不同，table多两个elements()和contains()方法，但是和containsValue()相同，并且其就是调用了上述方法

null值支持性不同，这里对map比较时不能用get查看是否为null，可能是没有，也可能就是null，要用containsKey()判断

HashMap不是线程安全的，效率会高，需要使用多线程操作时可以采用ConcurrentHashMap

因为ConcurrentHashMap虽然是线程安全的，但是使用了分段锁，因此会比Hashtable效率高很多倍，不会对整个数据进行锁定

初始容量大小和每次扩充容量大小不同

table 初始 11 每次扩充变为 2n+1

map 初始16 每次扩充变成2倍

给定初始则table直接用，map会扩充为2的幂次方大小------>侧重点不同，table关注hash结果更均匀，减少哈希冲突，map关注hash效率，取模时，模数是2的幂，可以用位运算效率高于除法。为了解决hash分布不均匀，map计算hash值方式不同

hash值

table key的hashcode

map key的hashcode 高低16位异或的结果







实现一个保证迭代顺序的HashMap

一般由java提供的，有序的HashMap为 LinkedHashMap，相对HashMap，其通过更大的时间和空间开销，维护了一个双向链表，保证了HashMap的有序

LinkedHashMap非线程安全

默认是按插入顺序排序，如果按访问顺序排序，调用get方法后，会将这次访问的元素移至链表尾部，不断访问可以形成按访问顺序排序的链表，可以重写removeEldestEntry方法返回true值指定插入元素时移除最老的元素

上述方式也就是通过LinkedHashMap实现LRU缓存机制，其提供了一个boolean值accessOrder，可以让用户指定是否实现LRU，默认为false即不使用这个参数时，默认的LinkedHashMap会使用插入顺序，true时就是访问顺序排序

~~~java
public static void main(String[] args)
{
 LinkedHashMap linkedHashMap =
   new LinkedHashMap(16, 0.75f, true);
 linkedHashMap.put("111", "111");
 linkedHashMap.put("222", "222");
 linkedHashMap.put("333", "333");
 linkedHashMap.put("444", "444");
 loopLinkedHashMap(linkedHashMap);
 linkedHashMap.get("111");
 loopLinkedHashMap(linkedHashMap);
 linkedHashMap.put("222", "2222");
 loopLinkedHashMap(linkedHashMap);
}
  
public static void loopLinkedHashMap(LinkedHashMap linkedHashMap)
{
 Set> set = inkedHashMap.entrySet();
 Iterator> iterator = set.iterator();
  
 while (iterator.hasNext())
 {
  System.out.print(iterator.next() + "\t");
 }
 System.out.println();
}
~~~





排序算法，稳定性，复杂度

排序算法的稳定度指的是：一个排序算法在执行后本来符合顺序的元素不会被交换位置	eg：两相等元素被交换位置则为不稳定的排序算法

简单标记各算法原理：

直接插入排序：每一个未被排序的元素和已排列元素进行比较并放在适当位置O(n^2)稳定

简单选择排序：找出序列中最小的元素和第一个交换位置，依次排序

O(n^2)不稳定

shell(希尔排序)：通过一个间隔gap将序列分为子序列进行直接插入排序，第i个和第gap+i个进行比较换位，<O(n^2)，不稳定

冒泡排序：第1和2比，2和3比……一趟就可以确定一个最大或最小的，依次进行，O(n^2)，稳定

快速排序：选一个元素(first)，从前后分别找，大的往后换，小的往前换，一次结束后对左右递归O(nlogn)，不稳定

堆排序：构造一个大根堆或者小根堆，将最大元素换到末尾并且其他元素再次构造成一个堆，递归完成则数组有序，O(nlogn)，不稳定

基数排序：可以从最高有效位或者最低有效位开始，将当前位数字按顺序排序，并且按顺序放置，再去收集排列下一位数字，(先个位再十位……或反过来)O(d(n+r))，稳定--------->执行一次收集放置需要O(n+r)d个 位数

归并排序：分治思想，将序列不断分解，自序列长度为1时就开始，递归排序，当前序列有序后再和上一级序列进行排序O(nlogn)，稳定





/var/folders/11/s33brm7s2xl6wmbmz1302s_c0000gn/T/

`